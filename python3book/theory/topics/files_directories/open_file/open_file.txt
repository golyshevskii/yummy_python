И так, начнем с открытия файла.
Чтобы организовать тусовочку с файлом, нам необходимо создать объект этого файла, 
используя функцию open()-(открыть):

ее внутренности:
open(path, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
где,

path - путь к файлу
mode - режим открытия файла
buffering - размер буфера(временное место, где хранятся данные)
encoding - кодировка
errors - уровень обработки ошибок
newline - режим обработки символов конца строки
closefd - режим работы файлового дискриптера(уникальное число файла)
opener - возращение дискриптера файла


1. path:
путь к файлу может быть 
относительным - 
поиск в папочке, в которой мы находимся. Например мы в С:\python\kek, 
и ищем в kek файл lol.py, записали бы мы это так 'lol.py' 
и абсолютным - 
поиск начинается с корня и до файла. Например 'С:\\python\\kek\\lol.py'

2. mode:
r - только чтение файла. Если файл не существует, то возбуждается FileNotFoundError;
r+ - чтение и запись. Если файл не существует, то возбуждается FileNotFoundError;
w - запись. Если файл не существует, он будет создан. Если файл существует, он будет перезаписан;
w+ - чтение и запись. Если файл не существует, он будет создан. Если файл существует, он будет перезаписан;
a - запись. Если файл не существует, он будет создан. Запись осуществляется в конец файла;
a+ - чтение и запись. Если файл не существует, он будет создан. Запись осуществляется в конец файла;
x - создание файла для записи. Если файл уже существует, возбуждается исключение FileExistsError;
x+ - создание файла для записи и чтения. Если файл уже существует, возбуждается исключение FileExistsError.

также можно определять модификаторы вместе с тегами:
b — файл будет открыт в бинарном режиме;
t — файл будет открыт в текстовом режиме.

например: 'rb', 'r+b'.

3. buffering:
0 - данные из буфера будут записаны в файл сразу;
1 - дынные будут записаны построчно;
-1 - размер буфера по умолчанию.

4. encoding:
стандартная кодировка utf-8

5. errors:
основные
'strict' - возбуждение ошибки ValueError(по умолчанию);
'replace' - замена неизвестного символа символом вопроса;
'ignore' - игнорирование неизвестного символа.

6. newline:
основные
None - выполняется стандартная обработка символов конца строки;
'' - обработка не выполняется.


Вперед к примерчику ^^

Например у нас есть текстовый файл readme.txt, расположенный в папке kek
(C:\python\kek), нам необходимо открыть файл на чтение, извеч из файла данные и
выписать их в консоль.

Эту задачу можно решить с помощью прикольной инструкции with <function> as <name>.
Она позволяет нам принимать объект(наш файл) открыть его, сделать с ним все, что
у нас на уме и например закрыть его, вне зависимости от того, произошло исключение внутри этой инструкции или нет.

let's do this:
with open('readme.txt', 'r') as file:
    for line in file:
        print(repr(line))

WHAT??? - мы определили конструкцию with, на место функции поставили функцию open(), в которой
мы определили относительный путь к файлу 'readme.txt' и режим чтения файла 'r', и назвали этот объект, как file.
далее мы определяем цикл for вместе с переменной line, которая будет принимать значения из объекта файл(строки),
и с каждой итерацией(проход по телу цикла), выписывать значение(строчку) переменной line в консоль выводя все символы строки
(используем функцию repr()).









